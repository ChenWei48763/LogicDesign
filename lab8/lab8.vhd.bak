LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

ENTITY lab8 IS
    PORT (
        -- Global Inputs
        CLOCK_50 : IN STD_LOGIC;
        KEY      : IN STD_LOGIC_VECTOR(1 DOWNTO 0); -- KEY(0)=RESETn, KEY(1)=EXECUTE
        SW       : IN STD_LOGIC_VECTOR(15 DOWNTO 0);

        -- Outputs to 7-Segment Displays
        HEX0, HEX1, HEX2, HEX3, HEX4, HEX5 : OUT STD_LOGIC_VECTOR(6 DOWNTO 0)
    );
END ENTITY lab8;

ARCHITECTURE behavioral OF lab8 IS

    -- Component for HEX to 7-Segment conversion
    COMPONENT hex_to_7seg IS
        PORT (
            hex_in  : IN  STD_LOGIC_VECTOR(3 DOWNTO 0);
            seg_out : OUT STD_LOGIC_VECTOR(6 DOWNTO 0)
        );
    END COMPONENT;

    -- Type for the register file (4 registers, 8 bits each)
    TYPE T_REGISTER_FILE IS ARRAY (0 TO 3) OF STD_LOGIC_VECTOR(7 DOWNTO 0);
    SIGNAL s_registers : T_REGISTER_FILE := (OTHERS => (OTHERS => '0'));

    -- State machine definition
    TYPE T_STATE IS (S_IDLE, S_EXECUTE);
    SIGNAL s_current_state, s_next_state : T_STATE;

    -- Signals for inputs
    SIGNAL s_data_bus      : STD_LOGIC_VECTOR(7 DOWNTO 0);
    SIGNAL s_instruction   : STD_LOGIC_VECTOR(7 DOWNTO 0);
    SIGNAL s_opcode        : STD_LOGIC_VECTOR(3 DOWNTO 0);
    SIGNAL s_rs_addr       : STD_LOGIC_VECTOR(1 DOWNTO 0);
    SIGNAL s_rt_addr       : STD_LOGIC_VECTOR(1 DOWNTO 0);

    -- Internal signals for instruction execution
    SIGNAL s_instr_reg     : STD_LOGIC_VECTOR(7 DOWNTO 0); -- Latched instruction
    SIGNAL s_rs_display_addr, s_rt_display_addr : STD_LOGIC_VECTOR(1 DOWNTO 0) := "00";

    -- Debouncing and edge detection for the execute button
    SIGNAL s_exec_key_q1, s_exec_key_q2, s_exec_key_q3 : STD_LOGIC;
    SIGNAL s_exec_pulse : STD_LOGIC;

    -- Signals for display values
    SIGNAL s_rs_val_to_display : STD_LOGIC_VECTOR(7 DOWNTO 0);
    SIGNAL s_rt_val_to_display : STD_LOGIC_VECTOR(7 DOWNTO 0);

BEGIN

    --==================================================================
    -- I/O Mapping and Connections
    --==================================================================
    s_data_bus    <= SW(7 DOWNTO 0);
    s_instruction <= SW(15 DOWNTO 8);

    -- Deconstruct instruction from switches for immediate use
    s_opcode  <= s_instruction(7 DOWNTO 4); -- Opcode from SW[15:12]
    s_rs_addr <= s_instruction(5 DOWNTO 4); -- Rs address from SW[11:10] --<-- 注意：根據您的圖片，Rs應為 SW[3:2] of 8-bit instruction, 但這裡用16bit SW 比較合理。我依照 SW[11:10] for Rs.
    s_rt_addr <= s_instruction(3 DOWNTO 2); -- Rt address from SW[9:8]  --<-- 注意：這裡改為 SW[9:8] for Rt.

    -- Connect register values to display logic
    s_rs_val_to_display <= s_registers(TO_INTEGER(UNSIGNED(s_rs_display_addr)));
    s_rt_val_to_display <= s_registers(TO_INTEGER(UNSIGNED(s_rt_display_addr)));

    --==================================================================
    -- Button Debouncer and Single-Pulse Generator for EXECUTE key
    --==================================================================
    PROCESS (CLOCK_50, KEY)
        -- Using active-low reset from KEY(0)
        VARIABLE reset_n : STD_LOGIC;
    BEGIN
        reset_n := KEY(0);
        IF reset_n = '0' THEN
            s_exec_key_q1 <= '0';
            s_exec_key_q2 <= '0';
            s_exec_key_q3 <= '0';
        ELSIF rising_edge(CLOCK_50) THEN
            s_exec_key_q1 <= KEY(1);
            s_exec_key_q2 <= s_exec_key_q1;
            s_exec_key_q3 <= s_exec_key_q2;
        END IF;
    END PROCESS;
    -- Generate a single clock cycle pulse on button press
    s_exec_pulse <= s_exec_key_q2 AND (NOT s_exec_key_q3);

    --==================================================================
    -- Main Processor State Machine and Logic
    --==================================================================
    PROCESS (CLOCK_50, KEY)
        VARIABLE reset_n : STD_LOGIC;

        -- Temporary variables for calculations
        VARIABLE v_rs_val, v_rt_val, v_result : STD_LOGIC_VECTOR(7 DOWNTO 0);
        VARIABLE v_rs_addr_int, v_rt_addr_int : INTEGER;
    BEGIN
        reset_n := KEY(0);
        IF reset_n = '0' THEN
            -- Asynchronous Reset
            s_registers <= (OTHERS => (OTHERS => '0'));
            s_current_state <= S_IDLE;
            s_rs_display_addr <= "00";
            s_rt_display_addr <= "00";
            
        ELSIF rising_edge(CLOCK_50) THEN
            -- State transition and execution logic
            CASE s_current_state IS

                WHEN S_IDLE =>
                    -- Wait for the execute pulse
                    IF s_exec_pulse = '1' THEN
                        -- Latch the current instruction and register addresses for execution
                        s_instr_reg <= s_instruction;
                        s_rs_display_addr <= s_instruction(5 DOWNTO 4); -- Latch display pointers
                        s_rt_display_addr <= s_instruction(3 DOWNTO 2);
                        s_current_state <= S_EXECUTE;
                    ELSE
                        s_current_state <= S_IDLE;
                    END IF;

                WHEN S_EXECUTE =>
                    -- Decode and execute the latched instruction
                    v_rs_addr_int := TO_INTEGER(UNSIGNED(s_instr_reg(5 DOWNTO 4)));
                    v_rt_addr_int := TO_INTEGER(UNSIGNED(s_instr_reg(3 DOWNTO 2)));

                    v_rs_val := s_registers(v_rs_addr_int);
                    v_rt_val := s_registers(v_rt_addr_int);

                    CASE s_instr_reg(7 DOWNTO 4) IS -- Decode based on latched opcode
                        
                        -- 0000: Load Rs, Data --> Rs <= Data
                        WHEN "0000" => 
                            s_registers(v_rs_addr_int) <= s_data_bus;
                            
                        -- 0001: Move Rs, Rt --> Rs <= Rt
                        WHEN "0001" => 
                            s_registers(v_rs_addr_int) <= v_rt_val;
                            
                        -- === 其他指令 (選做) ===
                        -- 0010: Add Rs, Rt --> Rs <= Rs + Rt
                        WHEN "0010" =>
                            v_result := STD_LOGIC_VECTOR(UNSIGNED(v_rs_val) + UNSIGNED(v_rt_val));
                            s_registers(v_rs_addr_int) <= v_result;

                        -- 0011: And Rs, Rt --> Rs <= Rs AND Rt
                        WHEN "0011" =>
                            s_registers(v_rs_addr_int) <= v_rs_val AND v_rt_val;
                            
                        -- 0101: Sub(A-B) Rs, Rt --> Rs <= Rs - Rt
                        WHEN "0101" =>
                            v_result := STD_LOGIC_VECTOR(UNSIGNED(v_rs_val) - UNSIGNED(v_rt_val));
                            s_registers(v_rs_addr_int) <= v_result;

                        -- 1001: Sub(B-A) Rs, Rt --> Rs <= Rt - Rs
                        WHEN "1001" =>
                            v_result := STD_LOGIC_VECTOR(UNSIGNED(v_rt_val) - UNSIGNED(v_rs_val));
                            s_registers(v_rs_addr_int) <= v_result;

                        -- 0100: Slt Rs, Rt --> if (Rs < Rt) Rs=1; else Rs=0
                        WHEN "0100" =>
                            IF (UNSIGNED(v_rs_val) < UNSIGNED(v_rt_val)) THEN
                                s_registers(v_rs_addr_int) <= "00000001";
                            ELSE
                                s_registers(v_rs_addr_int) <= "00000000";
                            END IF;
                            
                        -- 其他未定義指令，不做任何事
                        WHEN OTHERS =>
                            NULL;
                    END CASE;
                    
                    -- Execution is done in one cycle, return to IDLE
                    s_current_state <= S_IDLE;
            END CASE;
        END IF;
    END PROCESS;

    --==================================================================
    -- 7-Segment Display Drivers
    --==================================================================
    -- Display BUS value (SW[7:0]) on HEX1, HEX0
    disp_bus_h: hex_to_7seg PORT MAP(hex_in => s_data_bus(7 DOWNTO 4), seg_out => HEX1);
    disp_bus_l: hex_to_7seg PORT MAP(hex_in => s_data_bus(3 DOWNTO 0), seg_out => HEX0);

    -- Display Rs value on HEX3, HEX2
    disp_rs_h: hex_to_7seg PORT MAP(hex_in => s_rs_val_to_display(7 DOWNTO 4), seg_out => HEX3);
    disp_rs_l: hex_to_7seg PORT MAP(hex_in => s_rs_val_to_display(3 DOWNTO 0), seg_out => HEX2);

    -- Display Rt value on HEX5, HEX4
    disp_rt_h: hex_to_7seg PORT MAP(hex_in => s_rt_val_to_display(7 DOWNTO 4), seg_out => HEX5);
    disp_rt_l: hex_to_7seg PORT MAP(hex_in => s_rt_val_to_display(3 DOWNTO 0), seg_out => HEX4);

END ARCHITECTURE behavioral;